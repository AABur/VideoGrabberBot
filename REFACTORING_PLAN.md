# План рефакторинга VideoGrabberBot (Пет-проект)

## Цель рефакторинга

Исправить критичные проблемы в проекте VideoGrabberBot, сосредоточившись на стабильности и качестве кода для пет-проекта.

## Основные принципы

- **Исправить реальные проблемы** - сфокусироваться на подтвержденных багах
- **Стабильность** - устранить потенциальные источники сбоев
- **Поддерживаемость** - улучшить читаемость и структуру кода
- **Тестируемость** - сохранить высокое покрытие тестами

## Текущее состояние проекта

### ✅ Сильные стороны
- Отличная архитектура и модульность
- Высокое покрытие тестами 97.5%
- Современные практики Python
- Хорошая безопасность
- Качественная документация
- Простая и понятная структура

### ⚠️ Подтвержденные проблемы
1. **URL_STORAGE утечка памяти** - критичная проблема (`storage.py:8`)
2. **Блокирующие yt-dlp операции** - блокируют event loop (`downloader.py:49-54`)
3. **Небезопасный доступ к queue._queue** - race conditions (`queue.py:74,96,117`)

## План исправлений по приоритетам

### Приоритет 1: КРИТИЧНЫЕ исправления (1-2 дня)

#### 1.1 Исправить утечку памяти URL_STORAGE

**Проблема**: 
- Файл: `bot/services/storage.py`, строка 8
- URL_STORAGE растет бесконечно без механизма очистки
- Каждый запрос добавляет запись, но никогда не удаляет

**Подход к решению**:
- Добавить TTL (time-to-live) для записей
- Реализовать автоматическую очистку устаревших записей
- Ограничить максимальный размер хранилища

#### 1.2 Исправить блокирующие yt-dlp операции

**Проблема**:
- Файл: `bot/services/downloader.py`, строки 49-54
- Синхронные вызовы `ydl.extract_info()` и `ydl.download()` блокируют event loop
- Все пользователи ждут пока выполняется одна загрузка

**Подход к решению**:
- Вынести yt-dlp операции в ThreadPoolExecutor
- Сохранить асинхронный интерфейс для вызывающего кода
- Ограничить количество одновременных загрузок

#### 1.3 Исправить небезопасный доступ к queue._queue

**Проблема**:
- Файл: `bot/services/queue.py`, строки 74, 96, 117
- Прямое обращение к приватному атрибуту `self.queue._queue`
- Потенциальные race conditions при конкурентном доступе

**Подход к решению**:
- Заменить прямой доступ на thread-safe методы
- Добавить собственное отслеживание состояния очереди
- Использовать asyncio.Lock для синхронизации

### Приоритет 2: УЛУЧШЕНИЯ качества кода (1 день)

#### 2.1 Улучшить обработку ошибок

**Текущая проблема**: 
- Слишком общие исключения в коде
- Недостаточно специфичные сообщения об ошибках

**Подход к решению**:
- Создать иерархию специфичных исключений
- Улучшить сообщения об ошибках для пользователей
- Добавить контекстную информацию в логи

#### 2.2 Добавить базовые лимиты ресурсов

**Проблема**:
- Отсутствие ограничений на размер файлов
- Нет ограничений на количество задач в очереди

**Подход к решению**:
- Добавить проверку размера файла перед загрузкой
- Ограничить размер очереди загрузок
- Добавить максимальное время ожидания

### Приоритет 3: ОПТИМИЗАЦИЯ (1 день)

#### 3.1 Упростить конфигурацию

**Подход**:
- Консолидировать настройки в одном месте
- Упростить управление переменными окружения
- Добавить валидацию конфигурации при запуске

#### 3.2 Очистка кода

**Подход**:
- Удалить неиспользуемые импорты и функции
- Упростить сложные условные конструкции
- Улучшить читаемость кода

## Что НЕ ТРОГАЕМ (работает хорошо)

1. **Структуру проекта** - она логична и понятна
2. **Тесты** - покрытие 97.5%, все проходят
3. **Базовую архитектуру** - handlers/services/utils хорошо разделены
4. **Безопасность** - авторизация и валидация URL работают
5. **Логирование** - loguru настроен корректно
6. **Docker конфигурацию** - работает стабильно

## Что НЕ СУЩЕСТВУЕТ (удалить из плана)

1. **concurrent_queue.py** - этого файла нет в проекте
2. **Сложные системы мониторинга** - их нет в текущем коде
3. **Connection pooling** - не используется
4. **Продвинутые метрики** - отсутствуют в проекте

## Временные рамки

| Этап | Задачи | Ожидаемый результат |
|------|--------|-------------------|
| **День 1** | Исправить утечку памяти и блокировки | Стабильная работа без зависаний |
| **День 2** | Улучшить обработку ошибок и добавить лимиты | Лучшая диагностика и защита от перегрузок |
| **День 3** | Оптимизация и очистка кода | Чистый и поддерживаемый код |

## Критерии успеха

### Функциональные:
- Бот не зависает при загрузке видео
- Память не растет бесконечно
- Ошибки обрабатываются корректно
- Все тесты продолжают проходить

### Нефункциональные:
- Код легко читается и понимается
- Архитектура остается простой
- Покрытие тестами не падает ниже 95%
- Время отклика приемлемое для пет-проекта

## Заключение

Этот план сосредоточен на **фактических проблемах** текущего кода, выявленных через анализ реального состояния проекта. Цель - получить стабильный, надежный и поддерживаемый Telegram-бот для личного использования.